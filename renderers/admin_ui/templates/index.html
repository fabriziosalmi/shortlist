<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéõÔ∏è Shortlist Control Room</title>
    <style>
        /* Modern, clean CSS styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #2d3748;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 2rem;
        }

        .section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }

        .section-header {
            background: #f8fafc;
            padding: 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .section-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2d3748;
        }

        .section-content {
            padding: 1.5rem;
        }

        .editor-section {
            grid-column: 1 / -1;
        }

        /* Status indicators */
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-dot.alive { background: #48bb78; }
        .status-dot.dead { background: #f56565; }
        .status-dot.healthy { background: #48bb78; }
        .status-dot.unhealthy { background: #ed8936; }

        /* Tables */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .table th,
        .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.875rem;
        }

        .table th {
            background: #f8fafc;
            font-weight: 600;
            color: #4a5568;
        }

        .table tbody tr:hover {
            background: #f8fafc;
        }

        /* Stats cards */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: #f8fafc;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2d3748;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Editor */
        .editor-container {
            position: relative;
        }

        #shortlist-editor {
            width: 100%;
            min-height: 300px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            resize: vertical;
            background: #f8fafc;
            color: #2d3748;
        }

        #shortlist-editor:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .btn-warning {
            background: #ed8936;
            color: white;
        }

        .btn-warning:hover {
            background: #dd6b20;
        }

        /* Form elements */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #4a5568;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.875rem;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Response log */
        .response-log {
            background: #1a202c;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
            min-height: 100px;
            overflow-x: auto;
            margin-top: 1rem;
            white-space: pre-wrap;
            border: 1px solid #2d3748;
        }

        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                padding: 1rem;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .header h1 {
                font-size: 2rem;
            }
        }

        /* Utility classes */
        .text-center { text-align: center; }
        .text-small { font-size: 0.875rem; }
        .text-muted { color: #718096; }
        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .flex { display: flex; }
        .flex-between { justify-content: space-between; }
        .flex-center { justify-content: center; }
        .gap-1 { gap: 0.5rem; }
        .gap-2 { gap: 1rem; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéõÔ∏è Shortlist Control Room</h1>
        <p>Monitor your decentralized swarm and manage content securely</p>
    </div>

    <div class="container">
        <!-- Section 1: Swarm Status -->
        <div class="section">
            <div class="section-header">
                <h2>üìä Swarm Status</h2>
                <button id="refresh-status-btn" class="btn btn-secondary">
                    <span id="status-spinner" class="spinner" style="display: none;"></span>
                    üîÑ Refresh
                </button>
            </div>
            <div class="section-content">
                <div class="stats" id="stats-container">
                    <div class="stat-card">
                        <div class="stat-number" id="total-nodes">-</div>
                        <div class="stat-label">Total Nodes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="alive-nodes">-</div>
                        <div class="stat-label">Alive Nodes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="total-tasks">-</div>
                        <div class="stat-label">Total Tasks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="healthy-tasks">-</div>
                        <div class="stat-label">Healthy Tasks</div>
                    </div>
                </div>

                <h3 class="mb-1">Active Nodes</h3>
                <div id="nodes-container">
                    <table class="table" id="nodes-table">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Node ID</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody id="nodes-tbody">
                            <tr>
                                <td colspan="3" class="text-center text-muted">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="mb-1" style="margin-top: 1.5rem;">Task Assignments</h3>
                <div id="tasks-container">
                    <table class="table" id="tasks-table">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Task ID</th>
                                <th>Node</th>
                                <th>Last Heartbeat</th>
                            </tr>
                        </thead>
                        <tbody id="tasks-tbody">
                            <tr>
                                <td colspan="4" class="text-center text-muted">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Section 2: Governance API Status -->
        <div class="section">
            <div class="section-header">
                <h2>üõ°Ô∏è Governance API</h2>
                <button id="refresh-governance-btn" class="btn btn-secondary">
                    <span id="governance-spinner" class="spinner" style="display: none;"></span>
                    üîÑ Check
                </button>
            </div>
            <div class="section-content">
                <div id="governance-status" class="text-center text-muted">
                    Checking API availability...
                </div>
            </div>
        </div>

        <!-- Section 3: History & Rollback -->
        <div class="section">
            <div class="section-header">
                <h2>üïò History & Rollback</h2>
                <button id="refresh-history-btn" class="btn btn-secondary">
                    <span id="history-spinner" class="spinner" style="display: none;"></span>
                    üîÑ Refresh History
                </button>
            </div>
            <div class="section-content">
                <div class="text-small text-muted mb-1">
                    View the edit history of shortlist.json and safely revert a past change.
                </div>
                <table class="table" id="history-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Author</th>
                            <th>Description</th>
                            <th style="width: 120px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="history-tbody">
                        <tr>
                            <td colspan="4" class="text-center text-muted">History will load here...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Section 4: Secrets Management -->
        <div class="section">
            <div class="section-header">
                <h2>üîê Secrets Management</h2>
                <button id="refresh-secrets-btn" class="btn btn-secondary" disabled>
                    <span id="secrets-spinner" class="spinner" style="display:none;"></span>
                    üîÑ Refresh
                </button>
            </div>
            <div class="section-content">
                <div class="text-small text-muted mb-1">
                    Manage secure secrets used by renderers. Only keys are displayed here; values are never shown.
                </div>

                <div class="form-group">
                    <label class="form-label">Add / Update Secret</label>
                    <div class="flex gap-2">
                        <input id="secret-key" class="form-input" placeholder="SECRET_KEY (e.g., TELEGRAM_API_TOKEN)">
                        <input id="secret-value" type="password" class="form-input" placeholder="Secret value">
                        <button id="save-secret-btn" class="btn btn-primary" disabled>üíæ Save Secret</button>
                    </div>
                </div>

                <h3 class="mb-1">Configured Secrets</h3>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Key</th>
                            <th style="width: 120px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="secrets-tbody">
                        <tr>
                            <td colspan="2" class="text-center text-muted">Enter a maintainer token to view configured secrets.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Section 5: Shortlist Editor (Full Width) -->
        <div class="section editor-section">
            <div class="section-header">
                <h2>üìù Shortlist Editor</h2>
                <div class="flex gap-1">
                    <button id="refresh-content-btn" class="btn btn-secondary">
                        <span id="content-spinner" class="spinner" style="display: none;"></span>
                        üîÑ Refresh Content
                    </button>
                    <button id="format-json-btn" class="btn btn-secondary">
                        ‚ú® Format JSON
                    </button>
                </div>
            </div>
            <div class="section-content">
                <div class="editor-container">
                    <textarea
                        id="shortlist-editor"
                        placeholder="Loading shortlist content..."
                        spellcheck="false"
                    ></textarea>
                </div>

                <div style="margin-top: 1.5rem;">
                    <h3 class="mb-1">üéØ Actions</h3>

                    <div class="form-group">
                        <label for="api-token" class="form-label">
                            üîë API Token (Maintainer or Contributor)
                        </label>
                        <input
                            type="password"
                            id="api-token"
                            class="form-input"
                            placeholder="Enter your API token here..."
                        >
                        <small class="text-muted">
                            Token is not stored - re-enter each session for security
                        </small>
                    </div>

                    <div class="form-group">
                        <label for="proposal-description" class="form-label">
                            üìÑ Proposal Description (for Contributors)
                        </label>
                        <input
                            type="text"
                            id="proposal-description"
                            class="form-input"
                            placeholder="Describe your changes..."
                            value="Updated via Shortlist Control Room"
                        >
                    </div>

                    <div class="flex gap-2">
                        <button id="propose-btn" class="btn btn-warning">
                            <span id="propose-spinner" class="spinner" style="display: none;"></span>
                            üìù Propose Change (Pull Request)
                        </button>
                        <button id="apply-btn" class="btn btn-success">
                            <span id="apply-spinner" class="spinner" style="display: none;"></span>
                            ‚ö° Apply Direct Change (Admin)
                        </button>
                        <button id="preview-audio-btn" class="btn btn-secondary" disabled>
                            <span id="preview-audio-spinner" class="spinner" style="display: none;"></span>
                            üîä Preview Audio
                        </button>
                        <button id="preview-video-btn" class="btn btn-secondary" disabled>
                            <span id="preview-video-spinner" class="spinner" style="display: none;"></span>
                            üé¨ Preview Video
                        </button>
                    </div>

                    <div class="response-log" id="response-log">
Ready to execute commands...

üí° Tips:
- Use "Propose Change" for contributor-level access (creates PR for review)
- Use "Apply Direct Change" for maintainer-level access (immediate merge)
- Content can be JSON format or line-separated text
- Refresh content to see latest changes from Git
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Preview Modal -->
    <div id="preview-modal" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,0.7); align-items:center; justify-content:center;">
        <div style="background:#fff; padding:1rem; border-radius:8px; max-width:90vw; max-height:90vh;">
            <div class="flex flex-between mb-1">
                <h3>Preview</h3>
                <button id="close-preview" class="btn btn-secondary">‚úñ Close</button>
            </div>
            <div id="preview-container" style="display:flex; justify-content:center; align-items:center; max-height: 80vh;">
                <video id="preview-video" controls style="max-width:85vw; max-height:75vh; display:none;"></video>
                <audio id="preview-audio" controls style="width:85vw; display:none;"></audio>
            </div>
        </div>
    </div>

    <script>
        // üéõÔ∏è Shortlist Control Room JavaScript
        console.log('üéõÔ∏è Shortlist Control Room loaded');

        // DOM elements
        const elements = {
            // Status section
            refreshStatusBtn: document.getElementById('refresh-status-btn'),
            statusSpinner: document.getElementById('status-spinner'),
            totalNodes: document.getElementById('total-nodes'),
            aliveNodes: document.getElementById('alive-nodes'),
            totalTasks: document.getElementById('total-tasks'),
            healthyTasks: document.getElementById('healthy-tasks'),
            nodesTbody: document.getElementById('nodes-tbody'),
            tasksTbody: document.getElementById('tasks-tbody'),

            // Governance section
            refreshGovernanceBtn: document.getElementById('refresh-governance-btn'),
            governanceSpinner: document.getElementById('governance-spinner'),
            governanceStatus: document.getElementById('governance-status'),

            // Editor section
            refreshContentBtn: document.getElementById('refresh-content-btn'),
            contentSpinner: document.getElementById('content-spinner'),
            formatJsonBtn: document.getElementById('format-json-btn'),
            shortlistEditor: document.getElementById('shortlist-editor'),
            apiToken: document.getElementById('api-token'),
            proposalDescription: document.getElementById('proposal-description'),
            proposeBtn: document.getElementById('propose-btn'),
            proposeSpinner: document.getElementById('propose-spinner'),
            applyBtn: document.getElementById('apply-btn'),
            applySpinner: document.getElementById('apply-spinner'),
            responseLog: document.getElementById('response-log'),

            // Preview controls
            previewAudioBtn: document.getElementById('preview-audio-btn'),
            previewVideoBtn: document.getElementById('preview-video-btn'),
            previewAudioSpinner: document.getElementById('preview-audio-spinner'),
            previewVideoSpinner: document.getElementById('preview-video-spinner'),
            previewModal: document.getElementById('preview-modal'),
            closePreviewBtn: document.getElementById('close-preview'),
            previewVideoEl: document.getElementById('preview-video'),
            previewAudioEl: document.getElementById('preview-audio'),
            previewContainer: document.getElementById('preview-container'),

            // Secrets
            refreshSecretsBtn: document.getElementById('refresh-secrets-btn'),
            secretsSpinner: document.getElementById('secrets-spinner'),
            secretsTbody: document.getElementById('secrets-tbody'),
            saveSecretBtn: document.getElementById('save-secret-btn'),
            secretKeyInput: document.getElementById('secret-key'),
            secretValueInput: document.getElementById('secret-value'),

            // History section
            refreshHistoryBtn: document.getElementById('refresh-history-btn'),
            historySpinner: document.getElementById('history-spinner'),
            historyTbody: document.getElementById('history-tbody')
        };

        // Utility functions
        function showSpinner(spinner) {
            spinner.style.display = 'inline-block';
        }

        function hideSpinner(spinner) {
            spinner.style.display = 'none';
        }

        function logMessage(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : 'üîµ';
            elements.responseLog.textContent = `[${timestamp}] ${prefix} ${message}\n\n${elements.responseLog.textContent}`;
        }

        function logJson(data, prefix = '') {
            const timestamp = new Date().toLocaleTimeString();
            elements.responseLog.textContent = `[${timestamp}] ${prefix}\n${JSON.stringify(data, null, 2)}\n\n${elements.responseLog.textContent}`;
        }

        // API functions
        async function fetchSwarmStatus() {
            showSpinner(elements.statusSpinner);
            try {
                const response = await fetch('/api/swarm-status');
                const data = await response.json();

                if (response.ok) {
                    updateSwarmStatusUI(data);
                    logMessage('Swarm status updated', 'success');
                } else {
                    throw new Error(data.error || 'Failed to fetch swarm status');
                }
            } catch (error) {
                logMessage(`Error fetching swarm status: ${error.message}`, 'error');
                console.error('Swarm status error:', error);
            } finally {
                hideSpinner(elements.statusSpinner);
            }
        }

        async function fetchGovernanceStatus() {
            showSpinner(elements.governanceSpinner);
            try {
                const response = await fetch('/api/governance-status');
                const data = await response.json();

                updateGovernanceStatusUI(data);
                logMessage('Governance API status checked', 'success');
            } catch (error) {
                // Handle client-side fetch errors gracefully
                updateGovernanceStatusUI({
                    available: false,
                    error: error.message || 'Failed to check governance API status'
                });
                logMessage(`Error checking governance API: ${error.message}`, 'error');
            } finally {
                hideSpinner(elements.governanceSpinner);
            }
        }

        async function fetchShortlistContent() {
            showSpinner(elements.contentSpinner);
            try {
                const response = await fetch('/api/shortlist-content');
                const data = await response.json();

                if (response.ok) {
                    elements.shortlistEditor.value = data.content;
                    logMessage('Shortlist content loaded', 'success');
                } else {
                    throw new Error(data.error || 'Failed to fetch shortlist content');
                }
            } catch (error) {
                logMessage(`Error fetching shortlist content: ${error.message}`, 'error');
            } finally {
                hideSpinner(elements.contentSpinner);
            }
        }

        function togglePreviewButtons() {
            const hasToken = !!elements.apiToken.value.trim();
            elements.previewAudioBtn.disabled = !hasToken;
            elements.previewVideoBtn.disabled = !hasToken;
            // Secrets section enablement
            elements.refreshSecretsBtn.disabled = !hasToken;
            elements.saveSecretBtn.disabled = !hasToken;
        }
            const hasToken = !!elements.apiToken.value.trim();
            elements.previewAudioBtn.disabled = !hasToken;
            elements.previewVideoBtn.disabled = !hasToken;
        }

        async function proposeChange() {
            const token = elements.apiToken.value.trim();
            const content = elements.shortlistEditor.value.trim();
            const description = elements.proposalDescription.value.trim();

            if (!token) {
                logMessage('Please enter your API token', 'error');
                return;
            }

            if (!content) {
                logMessage('Please enter content in the editor', 'error');
                return;
            }

            showSpinner(elements.proposeSpinner);
            elements.proposeBtn.disabled = true;

            try {
                const response = await fetch('/ui/propose', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        token: token,
                        content: content,
                        description: description
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    logMessage(`Proposal created successfully! PR: ${data.pull_request_url}`, 'success');
                    logJson(data, 'üìù Proposal Response:');
                } else {
                    throw new Error(data.error || `HTTP ${response.status}`);
                }
            } catch (error) {
                logMessage(`Proposal failed: ${error.message}`, 'error');
            } finally {
                hideSpinner(elements.proposeSpinner);
                elements.proposeBtn.disabled = false;
            }
        }

        async function applyChange() {
            const token = elements.apiToken.value.trim();
            const content = elements.shortlistEditor.value.trim();

            if (!token) {
                logMessage('Please enter your API token', 'error');
                return;
            }

            if (!content) {
                logMessage('Please enter content in the editor', 'error');
                return;
            }

            if (!confirm('‚ö†Ô∏è This will immediately apply changes to the shortlist. Are you sure?')) {
                return;
            }

            showSpinner(elements.applySpinner);
            elements.applyBtn.disabled = true;

            try {
                const response = await fetch('/ui/apply', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        token: token,
                        content: content
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    logMessage(`Changes applied successfully! Merged: ${data.merge_sha}`, 'success');
                    logJson(data, '‚ö° Apply Response:');
                    // Refresh content after successful apply
                    setTimeout(fetchShortlistContent, 2000);
                } else {
                    throw new Error(data.error || `HTTP ${response.status}`);
                }
            } catch (error) {
                logMessage(`Apply failed: ${error.message}`, 'error');
            } finally {
                hideSpinner(elements.applySpinner);
                elements.applyBtn.disabled = false;
            }
        }

        async function fetchHistory() {
            const token = elements.apiToken.value.trim();
            if (!token) {
                logMessage('Please enter your API token to fetch history', 'error');
                return;
            }
            showSpinner(elements.historySpinner);
            try {
                const resp = await fetch(`/api/history?token=${encodeURIComponent(token)}`);
                const data = await resp.json();
                if (!resp.ok) {
                    throw new Error(data.error || `HTTP ${resp.status}`);
                }
                renderHistory(data);
                logMessage('History loaded', 'success');
            } catch (err) {
                logMessage(`Failed to load history: ${err.message}`, 'error');
            } finally {
                hideSpinner(elements.historySpinner);
            }
        }

        function renderHistory(entries) {
            elements.historyTbody.innerHTML = '';
            if (!Array.isArray(entries) || entries.length === 0) {
                elements.historyTbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No history entries found</td></tr>';
                return;
            }
            entries.forEach((e) => {
                const tr = document.createElement('tr');
                const dateStr = new Date(e.date.replace(' ', 'T')).toLocaleString();
                tr.innerHTML = `
                    <td class="text-small">${dateStr}</td>
                    <td class="text-small">${e.author}</td>
                    <td>${escapeHtml(e.subject || '')}</td>
                    <td>
                        <button class="btn btn-warning btn-revert" data-hash="${e.hash}">‚Ü©Ô∏è Revert</button>
                    </td>
                `;
                elements.historyTbody.appendChild(tr);
            });
            // Bind revert buttons
            document.querySelectorAll('.btn-revert').forEach(btn => {
                btn.addEventListener('click', async (ev) => {
                    const hash = ev.currentTarget.getAttribute('data-hash');
                    await revertCommit(hash);
                });
            });
        }

        async function revertCommit(commitHash) {
            const token = elements.apiToken.value.trim();
            if (!token) {
                logMessage('Please enter your API token to perform a revert', 'error');
                return;
            }
            if (!commitHash) return;
            const confirmMsg = `‚ö†Ô∏è Are you sure you want to revert commit ${commitHash.slice(0,8)}?`;
            if (!confirm(confirmMsg)) return;

            showSpinner(elements.historySpinner);
            try {
                const resp = await fetch('/ui/revert', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token, commit_hash: commitHash })
                });
                const data = await resp.json();
                if (!resp.ok) {
                    throw new Error(data.error || `HTTP ${resp.status}`);
                }
                logMessage(`Rollback completed. PR: ${data.pull_request_url || 'merged'}`, 'success');
                logJson(data, '‚Ü©Ô∏è Revert Response:');
                // Refresh history and editor after a short delay
                setTimeout(() => { fetchHistory(); fetchShortlistContent(); }, 2000);
            } catch (err) {
                logMessage(`Rollback failed: ${err.message}`, 'error');
            } finally {
                hideSpinner(elements.historySpinner);
            }
        }

        function escapeHtml(str) {
            return str.replace(/[&<>"]/g, function(c) {
                return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c];
            });
        }

        async function generatePreview(rendererType) {
            const token = elements.apiToken.value.trim();
            const contentText = elements.shortlistEditor.value.trim();
            if (!token) { logMessage('Please enter your API token', 'error'); return; }
            if (!contentText) { logMessage('Please enter content in the editor', 'error'); return; }
            let parsed;
            try {
                parsed = JSON.parse(contentText);
            } catch (e) {
                logMessage('Please provide valid JSON content for preview', 'error');
                return;
            }

            const spinner = rendererType === 'audio' ? elements.previewAudioSpinner : elements.previewVideoSpinner;
            showSpinner(spinner);
            try {
                const resp = await fetch('/ui/preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token, renderer_type: rendererType, content: parsed })
                });
                if (!resp.ok) {
                    const err = await resp.json().catch(() => ({ error: `HTTP ${resp.status}` }));
                    throw new Error(err.error || `HTTP ${resp.status}`);
                }
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                // Show modal and play
                elements.previewModal.style.display = 'flex';
                elements.previewAudioEl.style.display = 'none';
                elements.previewVideoEl.style.display = 'none';
                if (rendererType === 'video') {
                    elements.previewVideoEl.src = url; elements.previewVideoEl.style.display = 'block'; elements.previewVideoEl.play();
                } else {
                    elements.previewAudioEl.src = url; elements.previewAudioEl.style.display = 'block'; elements.previewAudioEl.play();
                }
                logMessage('Preview generated successfully', 'success');
            } catch (e) {
                logMessage(`Preview failed: ${e.message}`, 'error');
            } finally {
                hideSpinner(spinner);
            }
        }

        async function fetchSecrets() {
            const token = elements.apiToken.value.trim();
            if (!token) return;
            showSpinner(elements.secretsSpinner);
            try {
                const resp = await fetch(`/api/secrets?token=${encodeURIComponent(token)}`);
                const data = await resp.json();
                if (!resp.ok) throw new Error(data.error || `HTTP ${resp.status}`);
                renderSecrets(data.secrets || []);
            } catch (e) {
                logMessage(`Failed to load secrets: ${e.message}`, 'error');
            } finally {
                hideSpinner(elements.secretsSpinner);
            }
        }

        function renderSecrets(keys) {
            elements.secretsTbody.innerHTML = '';
            if (!Array.isArray(keys) || keys.length === 0) {
                elements.secretsTbody.innerHTML = '<tr><td colspan="2" class="text-center text-muted">No secrets configured</td></tr>';
                return;
            }
            keys.forEach((k) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${escapeHtml(k)}</td>
                    <td>
                        <button class="btn btn-warning btn-delete-secret" data-key="${k}">üóëÔ∏è Delete</button>
                    </td>
                `;
                elements.secretsTbody.appendChild(tr);
            });
            document.querySelectorAll('.btn-delete-secret').forEach(btn => {
                btn.addEventListener('click', async (ev) => {
                    const key = ev.currentTarget.getAttribute('data-key');
                    await deleteSecret(key);
                });
            });
        }

        async function saveSecret() {
            const token = elements.apiToken.value.trim();
            const key = elements.secretKeyInput.value.trim();
            const value = elements.secretValueInput.value;
            if (!token) { logMessage('Please enter your API token', 'error'); return; }
            if (!key || !value) { logMessage('Please provide both secret key and value', 'error'); return; }
            showSpinner(elements.secretsSpinner);
            try {
                const resp = await fetch('/ui/secrets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token, key, value })
                });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data.error || `HTTP ${resp.status}`);
                logMessage(`Secret ${key} saved`, 'success');
                elements.secretValueInput.value = '';
                fetchSecrets();
            } catch (e) {
                logMessage(`Failed to save secret: ${e.message}`, 'error');
            } finally {
                hideSpinner(elements.secretsSpinner);
            }
        }

        async function deleteSecret(key) {
            const token = elements.apiToken.value.trim();
            if (!token) { logMessage('Please enter your API token', 'error'); return; }
            if (!confirm(`Delete secret ${key}?`)) return;
            showSpinner(elements.secretsSpinner);
            try {
                const resp = await fetch('/ui/secrets', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token, key })
                });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data.error || `HTTP ${resp.status}`);
                logMessage(`Secret ${key} deleted`, 'success');
                fetchSecrets();
            } catch (e) {
                logMessage(`Failed to delete secret: ${e.message}`, 'error');
            } finally {
                hideSpinner(elements.secretsSpinner);
            }
        }

        function formatJson() {
            try {
                const content = elements.shortlistEditor.value.trim();
                const parsed = JSON.parse(content);
                elements.shortlistEditor.value = JSON.stringify(parsed, null, 2);
                logMessage('JSON formatted successfully', 'success');
            } catch (error) {
                logMessage(`JSON format error: ${error.message}`, 'error');
            }
        }

        // UI update functions
        function updateSwarmStatusUI(data) {
            // Update stats
            elements.totalNodes.textContent = data.stats.total_nodes;
            elements.aliveNodes.textContent = data.stats.alive_nodes;
            elements.totalTasks.textContent = data.stats.total_tasks;
            elements.healthyTasks.textContent = data.stats.healthy_tasks;

            // Update nodes table
            elements.nodesTbody.innerHTML = '';
            if (data.nodes.length === 0) {
                elements.nodesTbody.innerHTML = '<tr><td colspan="3" class="text-center text-muted">No nodes found</td></tr>';
            } else {
                data.nodes.forEach(node => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>
                            <span class="status-dot ${node.is_alive ? 'alive' : 'dead'}"></span>
                            ${node.is_alive ? 'Alive' : 'Offline'}
                        </td>
                        <td title="${node.full_id}">${node.id}</td>
                        <td class="text-small">${node.time_since_last_seen}</td>
                    `;
                    elements.nodesTbody.appendChild(row);
                });
            }

            // Update tasks table
            elements.tasksTbody.innerHTML = '';
            if (data.tasks.length === 0) {
                elements.tasksTbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No tasks assigned</td></tr>';
            } else {
                data.tasks.forEach(task => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>
                            <span class="status-dot ${task.is_healthy ? 'healthy' : 'unhealthy'}"></span>
                            ${task.status}
                        </td>
                        <td>${task.task_id}</td>
                        <td title="${task.full_node_id}">${task.node_id}</td>
                        <td class="text-small">${task.time_since_heartbeat}</td>
                    `;
                    elements.tasksTbody.appendChild(row);
                });
            }
        }

        function updateGovernanceStatusUI(data) {
            if (data.available) {
                const status = data.status;
                elements.governanceStatus.innerHTML = `
                    <div style="color: #48bb78; margin-bottom: 1rem;">
                        ‚úÖ Governance API Available
                    </div>
                    <div class="stats" style="margin: 0;">
                        <div class="stat-card">
                            <div class="stat-number">${status.maintainer_auth_configured ? '‚úÖ' : '‚ùå'}</div>
                            <div class="stat-label">Maintainer Auth</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${status.contributor_auth_configured ? '‚úÖ' : '‚ùå'}</div>
                            <div class="stat-label">Contributor Auth</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${status.git_auth_configured ? '‚úÖ' : '‚ùå'}</div>
                            <div class="stat-label">Git Auth</div>
                        </div>
                    </div>
                    <div class="text-small text-muted" style="margin-top: 1rem;">
                        Repository: ${status.github_repo || 'Not configured'}
                    </div>
                `;
            } else {
                // Provide user-friendly error states based on backend categorization
                let errorMessage = data.error || 'Service is currently unavailable';
                let helpText = data.message || '';

                // Use structured error types from backend if available
                if (data.error_type) {
                    switch (data.error_type) {
                        case 'no_assignment':
                            errorMessage = 'Task not assigned';
                            helpText = 'No node has claimed the governance API task yet. This will happen automatically when a properly configured node joins the swarm.';
                            break;
                        case 'stale_assignment':
                            errorMessage = 'Task assignment expired';
                            helpText = 'The assigned node appears to be inactive. The task should be reassigned automatically to another node.';
                            break;
                        case 'container_not_running':
                            errorMessage = 'Service not running';
                            helpText = 'The governance API container is not currently active. This may indicate missing environment variables or container startup issues.';
                            break;
                        case 'connection_error':
                            errorMessage = 'Connection failed';
                            helpText = 'Cannot connect to the governance API service. It may be starting up or have networking issues.';
                            break;
                        case 'timeout':
                            errorMessage = 'Service timeout';
                            helpText = 'The governance API service is not responding. It may be overloaded or misconfigured.';
                            break;
                        case 'http_error':
                            errorMessage = 'Service error';
                            helpText = 'The governance API service returned an error. Check the container logs for details.';
                            break;
                        default:
                            errorMessage = data.error;
                            helpText = data.message || 'There may be an issue with the service configuration.';
                    }
                } else {
                    // Fallback for legacy error formats
                    if (data.error && data.error.includes('task not assigned')) {
                        errorMessage = 'Task not assigned';
                        helpText = 'No node has claimed the governance API task yet. Wait for a node to pick it up automatically.';
                    }
                }

                elements.governanceStatus.innerHTML = `
                    <div style="color: #f56565; margin-bottom: 1rem;">
                        ‚ùå Governance API Unavailable
                    </div>
                    <div style="color: #718096; margin-bottom: 0.5rem; font-weight: 500;">
                        ${errorMessage}
                    </div>
                    <div style="color: #a0aec0; font-size: 0.875rem; line-height: 1.4;">
                        ${helpText}
                    </div>
                    <div style="margin-top: 1rem; padding: 0.75rem; background: #f7fafc; border-radius: 6px; border-left: 4px solid #cbd5e0;">
                        <div style="font-weight: 500; color: #4a5568; margin-bottom: 0.5rem;">üí° To enable governance API:</div>
                        <div style="color: #718096; font-size: 0.875rem;">
                            1. Set environment variables: GIT_AUTH_TOKEN, GITHUB_REPO<br>
                            2. Start a node: <code style="background: #e2e8f0; padding: 2px 4px; border-radius: 3px;">python3 node.py</code><br>
                            3. Wait for automatic task assignment
                        </div>
                    </div>
                `;
            }
        }

        // Event listeners
        elements.refreshStatusBtn.addEventListener('click', fetchSwarmStatus);
        elements.refreshGovernanceBtn.addEventListener('click', fetchGovernanceStatus);
        elements.refreshHistoryBtn.addEventListener('click', fetchHistory);
        elements.refreshContentBtn.addEventListener('click', fetchShortlistContent);
        elements.formatJsonBtn.addEventListener('click', formatJson);
        elements.proposeBtn.addEventListener('click', proposeChange);
        elements.applyBtn.addEventListener('click', applyChange);
        elements.previewAudioBtn.addEventListener('click', () => generatePreview('audio'));
        elements.previewVideoBtn.addEventListener('click', () => generatePreview('video'));
        elements.closePreviewBtn.addEventListener('click', () => {
            elements.previewModal.style.display = 'none';
            elements.previewAudioEl.pause(); elements.previewVideoEl.pause();
            elements.previewAudioEl.src = ''; elements.previewVideoEl.src = '';
        });
        elements.apiToken.addEventListener('input', () => { togglePreviewButtons(); fetchSecrets(); });
        elements.refreshSecretsBtn.addEventListener('click', fetchSecrets);
        elements.saveSecretBtn.addEventListener('click', saveSecret);

        // Auto-refresh functionality
        function startAutoRefresh() {
            // Refresh swarm status every 30 seconds
            setInterval(fetchSwarmStatus, 30000);

            // Refresh governance status every 60 seconds
            setInterval(fetchGovernanceStatus, 60000);
        }

        // Initialize the application
        async function initialize() {
            logMessage('Initializing Shortlist Control Room...', 'info');

            // Load initial data
            await Promise.all([
                fetchSwarmStatus(),
                fetchGovernanceStatus(),
                fetchShortlistContent(),
                fetchHistory()
            ]);
            // Initial secrets load if token present
            if (elements.apiToken.value.trim()) { fetchSecrets(); }

            // Enable/disable preview buttons
            togglePreviewButtons();

            // Start auto-refresh
            startAutoRefresh();

            logMessage('Control Room ready! üéõÔ∏è', 'success');
        }

        // Start the application when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + Enter to apply changes (if token is entered)
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                if (elements.apiToken.value.trim()) {
                    if (e.shiftKey) {
                        proposeChange();
                    } else {
                        applyChange();
                    }
                }
            }

            // Ctrl/Cmd + R to refresh content
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                fetchShortlistContent();
            }
        });

        // Add tooltip for keyboard shortcuts
        elements.responseLog.title = `
Keyboard Shortcuts:
‚Ä¢ Ctrl/Cmd + Enter: Apply Direct Change
‚Ä¢ Ctrl/Cmd + Shift + Enter: Propose Change
‚Ä¢ Ctrl/Cmd + R: Refresh Content
        `.trim();
    </script>
</body>
</html>